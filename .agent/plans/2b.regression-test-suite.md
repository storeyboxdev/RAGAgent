# Add Server-Side Regression Test Suite

**Complexity:** ⚠️ **Medium** — One structural refactor + multiple test files with ESM mocking, but clear patterns repeat across files.

## Context

Modules 1 and 2 are complete, plus the LMStudio SDK conversion. Before starting Module 3, we need regression tests to catch breakage in existing features. Scope is **server-side only**: API integration tests for all endpoints + unit tests for pure library functions. No test infrastructure exists today — starting from scratch.

---

## Task 1: Install test dependencies

**File:** `server/package.json`

```bash
cd server && npm install --save-dev vitest supertest
```

Add scripts:
```json
"test": "vitest run",
"test:watch": "vitest"
```

**Validate:** `npm test` runs (will show "no test files" until we add them).

---

## Task 2: Extract Express app for testability

**Problem:** `server/index.js` creates the app and calls `app.listen()` inline — supertest needs to import the app without starting the server.

**Create `server/app.js`** — move all Express setup (middleware, routes) here, export the app:
- All imports (helmet, cors, express, routers, requireAuth)
- All `app.use()` calls
- Health endpoint
- `export default app`

**Modify `server/index.js`** — slim to just:
```js
import app from './app.js';
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
```

Keep the existing comment about env.js/Laminar.

**Validate:** `npm run dev` still starts the server normally.

---

## Task 3: Create vitest config

**Create `server/vitest.config.js`**

```js
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    env: {
      SUPABASE_URL: 'http://localhost:54321',
      SUPABASE_SERVICE_ROLE_KEY: 'test-key',
      SUPABASE_ANON_KEY: 'test-key',
      LMNR_PROJECT_API_KEY: 'test-key',
    },
  },
});
```

The `env` block provides dummy values so module-level `createClient()` in `supabase.js` doesn't crash at import time (before mocks take effect).

---

## Task 4: Create test helpers

### `server/tests/helpers/mockAuth.js`
Shared test user fixture and mock auth middleware factory:
- `TEST_USER = { id: 'test-user-uuid-1234', email: 'test@example.com' }`
- `TEST_TOKEN = 'test-bearer-token'`
- `createMockAuthMiddleware()` — returns `vi.fn()` that attaches user/token to req

### `server/tests/helpers/mockSupabase.js`
Factory for Supabase's chainable query pattern (`.from().select().eq().single()`):
- `createQueryChain(result)` — returns an object where `.select()`, `.insert()`, `.update()`, `.delete()`, `.eq()`, `.order()` all return `this`, and `.single()` resolves with `result`. Also supports bare `await chain` via `.then()`.
- `createMockSupabaseClient()` — returns `{ from: vi.fn(), storage: { from: vi.fn(...) } }`

### `server/tests/helpers/parseSSE.js`
SSE response parser for chat tests:
- `parseSSEEvents(text)` — splits on `\n\n`, filters `data:` lines, JSON-parses each

---

## Task 5: Unit tests — `server/tests/unit/chunking.test.js`

**File:** `server/lib/chunking.js` (pure function, no mocking needed)

Test cases:
1. Empty string → returns `[]`
2. Short text under chunkSize → single chunk with `chunkIndex: 0`
3. Two paragraphs that fit → single chunk containing both
4. Two paragraphs exceeding chunkSize → splits into 2 chunks
5. Overlap — second chunk starts with tail of first chunk content
6. Long single paragraph with sentences → splits at sentence boundaries
7. Custom `chunkSize` and `chunkOverlap` options are respected
8. Sequential `chunkIndex` values (0, 1, 2, ...)

**Validate:** `npm test` passes.

---

## Task 6: Integration tests — `server/tests/integration/health.test.js`

Module mocks required (because importing `app.js` transitively loads all routes):
- `@lmnr-ai/lmnr` → `{ observe: vi.fn((_, cb) => cb()), Laminar: { initialize: vi.fn(), setSpanOutput: vi.fn() } }`
- `../lib/supabase.js` → mock `createSupabaseClient` and `supabaseAdmin`
- `../lib/lmstudio.js` → mock all exports
- `../lib/embeddings.js` → mock `generateEmbeddings`, `generateEmbedding`
- `@lmstudio/sdk` → `{ tool: vi.fn((def) => def), LMStudioClient: vi.fn() }`

Tests:
1. `GET /api/health` → 200, body has `status: 'ok'` and `timestamp`

---

## Task 7: Integration tests — `server/tests/integration/threads.test.js`

Same module mocks as health, plus mock `requireAuth` to inject test user.

**Key pattern:** Before each test, configure `createSupabaseClient` to return a mock client, then set `mockClient.from.mockReturnValue(createQueryChain({ data: ..., error: null }))`.

Tests:
1. `GET /api/threads` → 200, returns array from supabase
2. `GET /api/threads` → 500 when supabase errors
3. `POST /api/threads` with `{ title: 'My Thread' }` → 201
4. `POST /api/threads` without title → 201, inserts with `'New Chat'`
5. `PATCH /api/threads/:id` with `{ title: 'Updated' }` → 200
6. `DELETE /api/threads/:id` → 204

---

## Task 8: Integration tests — `server/tests/integration/models.test.js`

Mock `lmstudio.js` exports directly (no Supabase chain needed — models.js doesn't use Supabase).

Tests:
1. `GET /api/models/llm` → 200, `{ models: [...], activeModel }` — verify `isLoaded` cross-referencing works (downloaded model in loaded set → `isLoaded: true`)
2. `GET /api/models/llm` → 500 on LMStudio error
3. `GET /api/models/embedding` → 200, `activeModel: null`
4. `PUT /api/models/active` with `{ modelId: 'llama3' }` → 200, calls `setActiveLlmModelId`
5. `PUT /api/models/active` without modelId → 400

---

## Task 9: Integration tests — `server/tests/integration/ingestion.test.js`

Mocks: `createSupabaseClient` (per-user client for insert/select/delete), `supabaseAdmin` (storage upload/download/remove + background processing), `generateEmbeddings`.

Tests:
1. `POST /api/ingestion/upload` with `.attach('file', buffer, 'test.txt')` → 201, returns doc with `status: 'pending'`
2. `POST /api/ingestion/upload` with no file → 400, `'No file provided'`
3. `POST /api/ingestion/upload` with storage error → 500
4. `GET /api/ingestion/documents` → 200, returns array
5. `GET /api/ingestion/documents` → 500 on error
6. `DELETE /api/ingestion/documents/:id` → 200, `{ success: true }` — mock fetch returning doc with `storage_path`
7. `DELETE /api/ingestion/documents/:id` doc not found → 404

Note: `processDocument()` fires-and-forgets after 201. Tests verify only the synchronous response — the background pipeline runs against mocks silently.

---

## Task 10: Integration tests — `server/tests/integration/chat.test.js`

Most complex file due to SSE streaming + LMStudio `.act()`.

Additional mocks:
- `../lib/lmstudio.js` → `getLlmModel` returns a mock model with `.act()` method
- `../lib/retrieval.js` → `searchDocuments` returns mock chunks
- `@lmstudio/sdk` → `tool: vi.fn((def) => def)` (passthrough)
- `@lmnr-ai/lmnr` → `observe` calls the callback directly

**Mock `.act()` pattern:**
```js
mockModel.act.mockImplementation(async (msgs, tools, opts) => {
  opts.onPredictionFragment({ content: 'Hello ' });
  opts.onPredictionFragment({ content: 'world' });
});
```

**SSE parsing:** supertest buffers full response (because handler calls `res.end()`). Parse with `parseSSEEvents(res.text)`.

Tests:
1. `POST /api/chat` missing `threadId` → 400
2. `POST /api/chat` missing `message` → 400
3. `POST /api/chat` thread not found → 404
4. `POST /api/chat` successful → 200 `text/event-stream`, contains `text_delta` events + `done` event
5. `POST /api/chat` first message → `done` event includes `title`
6. `POST /api/chat` verifies `model.act` called with correct messages (system + history + user)
7. `POST /api/chat` verifies thread updated in supabase with user + assistant messages only
8. `GET /api/chat/:threadId/messages` → 200, returns messages array
9. `GET /api/chat/:threadId/messages` thread not found → 404

---

## Task 11: Update CLAUDE.md — add Testing section

Add a new `## Testing` section to `CLAUDE.md` after the Development Flow section:

```markdown
## Testing

- Test framework: vitest + supertest (server-side only)
- Run all tests: `cd server && npm test`
- Run in watch mode: `cd server && npm run test:watch`
- Tests run with mocked external deps (no LMStudio or Supabase needed)
- **Run the full test suite after every new feature or rewrite** before committing
- Tests must all pass before a feature is considered complete
```

---

## Task 12: Update Development Flow in CLAUDE.md

Modify the existing Development Flow to include testing as a required step:

```markdown
## Development Flow

1. **Plan** - Create a detailed plan and save it to `.agent/plans/`
2. **Build** - Execute the plan to implement the feature
3. **Test** - Run `cd server && npm test` — all tests must pass
4. **Validate** - Test and verify the implementation works correctly. Use browser testing where applicable via an appropriate MCP
5. **Iterate** - Fix any issues found during testing or validation
```

---

## Task 13: Update PROGRESS.md — add regression test entry

Add a new section to PROGRESS.md documenting the test suite:

```markdown
### Regression Test Suite
[x]
- [x] Test infrastructure (vitest + supertest, app.js extraction)
- [x] Unit tests: chunking library
- [x] Integration tests: health, threads, models, ingestion, chat
- [x] CLAUDE.md updated with testing instructions
```

And add a note at the top-level that tests should be run after each module:

```markdown
> **Note:** Run `cd server && npm test` after completing any task. All tests must pass before moving on.
```

---

## Execution Order

```
Task 1 (deps) → Task 2 (app.js split) → Task 3 (vitest config) → Task 4 (helpers)
→ Task 5 (chunking unit tests) — verify infra works
→ Tasks 6-10 (integration tests, sequential)
→ Task 11 (CLAUDE.md testing section) → Task 12 (dev flow update) → Task 13 (PROGRESS.md)
```

## File Structure

```
server/
  app.js                              ← NEW (extracted from index.js)
  index.js                            ← MODIFIED (slim entrypoint)
  vitest.config.js                    ← NEW
  package.json                        ← MODIFIED (devDeps + scripts)
  tests/
    helpers/
      mockAuth.js                     ← NEW
      mockSupabase.js                 ← NEW
      parseSSE.js                     ← NEW
    unit/
      chunking.test.js               ← NEW
    integration/
      health.test.js                  ← NEW
      threads.test.js                 ← NEW
      models.test.js                  ← NEW
      ingestion.test.js              ← NEW
      chat.test.js                    ← NEW

CLAUDE.md                             ← MODIFIED (Testing section + dev flow update)
PROGRESS.md                           ← MODIFIED (regression test entry)
```

## Verification

Run `npm test` in `server/` — all tests pass with zero external dependencies running (no LMStudio, no Supabase needed).

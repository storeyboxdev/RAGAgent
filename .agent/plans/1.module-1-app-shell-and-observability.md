# Module 1: App Shell + Observability â€” Implementation Plan

## Context
Module 1 is in progress but only has a broken `server/` scaffold (uses non-existent Supabase APIs, missing imports, no package.json). No frontend, database schema, or Supabase setup exists. We will **delete the existing `server/` code** and build everything from scratch properly.

**Goal:** Deliver a working chat app with Supabase Auth, OpenAI Responses API (managed threads), SSE streaming, and Laminar observability.

**Complexity:** ðŸ”´ Complex â€” 9 sequential tasks spanning project init, database, backend, frontend, auth, chat UI, LLM integration, and observability.

---

## Task 1: Project Initialization

- Delete entire `server/` directory
- Create root `package.json` with workspace scripts (`concurrently` to run client + server)
- Create `server/package.json` with ESM (`"type": "module"`) and dependencies:
  - `@supabase/supabase-js`, `openai`, `@lmnr-ai/lmnr`, `express`, `cors`, `helmet`, `dotenv`, `zod`
  - devDeps: `nodemon`
- Create `.gitignore` (node_modules, .env, dist, .supabase)
- Create `.env.example` documenting all required env vars

**Validate:** `npm install` at root and `cd server && npm install` both succeed.

---

## Task 2: Supabase Local Setup

- `npx supabase init` from project root
- Configure `supabase/config.toml`: site_url = `http://localhost:5173`, email signup enabled, confirmations disabled (local dev)
- `npx supabase start` â€” start Docker containers
- Capture API URL, anon key, service role key â†’ populate `.env`

**Validate:** `npx supabase status` shows all services running; Supabase Studio accessible at `http://127.0.0.1:54323`.

---

## Task 3: Database Schema

Create `supabase/migrations/00001_create_threads.sql`:

- Enable `pgvector` extension (needed Module 2, set up now)
- `threads` table: `id` (uuid PK), `user_id` (FK â†’ auth.users), `title`, `openai_response_id` (text, nullable), `messages` (jsonb, default `[]`), `created_at`, `updated_at`
- Index on `user_id`
- RLS enabled with policies: users can only CRUD their own threads
- `updated_at` trigger

**Why `messages` JSONB?** OpenAI Responses API manages conversation state internally. We cache messages locally so the UI can display history when switching threads. This is a lightweight approach â€” Module 2 will add a proper `messages` table.

**Validate:** `npx supabase db reset` applies without errors; `threads` table visible in Studio with RLS enabled.

---

## Task 4: Backend Setup

Create modular Express server:

| File | Purpose |
|------|---------|
| `server/index.js` | Entry point â€” init Laminar (BEFORE OpenAI import), Express setup, mount routes |
| `server/lib/supabase.js` | `supabaseAdmin` (service role, bypasses RLS) + `createSupabaseClient(token)` (per-request, respects RLS) |
| `server/lib/openai.js` | OpenAI client instance |
| `server/middleware/auth.js` | `requireAuth` â€” validates Supabase JWT via `supabaseAdmin.auth.getUser(token)`, attaches `req.user` + `req.accessToken` |
| `server/routes/threads.js` | Thread CRUD (placeholder handlers) |
| `server/routes/chat.js` | Chat SSE endpoint (placeholder) |

**Validate:** Server boots on port 3001; `GET /api/health` returns 200; unauthenticated requests to `/api/threads` return 401.

---

## Task 5: Frontend Setup (can parallel with Task 4)

- `npm create vite@latest client -- --template react` (JavaScript)
- Install Tailwind CSS v4 + `@tailwindcss/vite` plugin
- Init shadcn/ui: `npx shadcn@latest init`, add components: button, input, card, dialog, scroll-area, separator, avatar
- Install `@supabase/supabase-js`
- Configure `vite.config.js`: Tailwind plugin, `@` alias, proxy `/api` â†’ `http://localhost:3001`
- Create `client/src/lib/supabase.js` (frontend Supabase client using `VITE_SUPABASE_URL` / `VITE_SUPABASE_ANON_KEY`)
- Create `client/.env` with Supabase credentials

**Validate:** `cd client && npm run dev` starts on `http://localhost:5173`; Tailwind and shadcn components render.

---

## Task 6: Auth Flow

| File | Purpose |
|------|---------|
| `client/src/context/AuthContext.jsx` | React context: `getSession()` on mount, `onAuthStateChange` listener, provides `user`, `session`, `loading` |
| `client/src/pages/AuthPage.jsx` | Login/signup form with tabs, uses `supabase.auth.signUp` / `signInWithPassword` |
| `client/src/pages/ChatPage.jsx` | Protected main page (placeholder for now) |
| `client/src/lib/api.js` | Fetch wrapper that auto-attaches `Authorization: Bearer <jwt>` from session |
| `client/src/App.jsx` | Routes: show AuthPage if no session, ChatPage if authenticated |

**Validate:** Sign up at `http://localhost:5173`, get redirected to chat page; user appears in Supabase Studio > Authentication; sign out and sign back in works; backend protected routes accept the JWT.

---

## Task 7: Chat UI

Build the chat interface layout:

```
+------------------+----------------------------------------+
| Thread List      | Chat Messages                          |
| [+ New Chat]     |   [Message bubbles...]                 |
| Thread 1 (bold)  |                                        |
| Thread 2         +----------------------------------------+
| Thread 3         | [Input box]                    [Send]  |
+------------------+----------------------------------------+
```

| File | Purpose |
|------|---------|
| `client/src/pages/ChatPage.jsx` | Main layout: sidebar + chat area, thread selection state |
| `client/src/components/ThreadList.jsx` | Fetches threads from `GET /api/threads`, new/delete actions |
| `client/src/components/ChatMessages.jsx` | Scrollable message display, auto-scroll on new messages |
| `client/src/components/ChatInput.jsx` | Text input, Enter to send, Shift+Enter for newline, disabled while streaming |
| `client/src/components/MessageBubble.jsx` | User vs assistant styling |

**Validate:** Create/select/delete threads via the sidebar; message input renders (sending wired in Task 8).

---

## Task 8: OpenAI Responses API Integration

Wire up the core chat functionality:

**`server/routes/threads.js`** â€” Full CRUD:
- `GET /` â€” list user's threads (ordered by `updated_at` desc)
- `POST /` â€” create thread
- `PATCH /:id` â€” update title
- `DELETE /:id` â€” delete thread

**`server/routes/chat.js`** â€” SSE streaming endpoint:
1. Fetch thread from DB to get `openai_response_id`
2. Call `openai.responses.create({ model: 'gpt-4o-mini', input: message, stream: true, previous_response_id })`
3. Stream `response.output_text.delta` events as `data: {"type":"text_delta","content":"..."}\n\n`
4. On completion, update thread: set new `openai_response_id`, append user + assistant messages to JSONB `messages` column, auto-title from first message
5. Send `data: {"type":"done"}\n\n` and close

**`GET /api/chat/:threadId/messages`** â€” returns cached messages from JSONB for thread history display

**Frontend SSE consumption** (in ChatPage.jsx):
- `fetch('/api/chat', { method: 'POST', ... })` then read `response.body.getReader()`
- Parse SSE lines, update assistant message content on each `text_delta`
- Mark streaming complete on `done` event

**Validate:** Send "Hello, what is RAG?" â†’ response streams token-by-token; send follow-up â†’ response references previous context (proves `previous_response_id` works); refresh page â†’ previous messages load from cache.

---

## Task 9: Laminar Observability

Laminar auto-instruments OpenAI calls via the init in `server/index.js`. Enhance with:

- Wrap chat handler in `observe({ name: 'chat_handler', sessionId: threadId, userId: req.user.id })`
- This groups traces by thread and user

**Validate:** Send a message; check Laminar dashboard for trace with root `chat_handler` span, child OpenAI span, token counts, and latency.

---

## Final File Structure

```
â”œâ”€â”€ package.json                    (root workspace scripts)
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .env / .env.example
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ config.toml
â”‚   â””â”€â”€ migrations/
â”‚       â””â”€â”€ 00001_create_threads.sql
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ index.js                    (Laminar init + Express)
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ supabase.js             (admin + per-request clients)
â”‚   â”‚   â””â”€â”€ openai.js
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ auth.js                 (Supabase JWT validation)
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ threads.js              (CRUD)
â”‚       â””â”€â”€ chat.js                 (SSE streaming)
â””â”€â”€ client/
    â”œâ”€â”€ package.json
    â”œâ”€â”€ .env
    â”œâ”€â”€ vite.config.js
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ App.jsx                 (auth routing)
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ supabase.js
    â”‚   â”‚   â”œâ”€â”€ api.js              (auth fetch wrapper)
    â”‚   â”‚   â””â”€â”€ utils.js            (shadcn cn helper)
    â”‚   â”œâ”€â”€ context/
    â”‚   â”‚   â””â”€â”€ AuthContext.jsx
    â”‚   â”œâ”€â”€ pages/
    â”‚   â”‚   â”œâ”€â”€ AuthPage.jsx
    â”‚   â”‚   â””â”€â”€ ChatPage.jsx
    â”‚   â””â”€â”€ components/
    â”‚       â”œâ”€â”€ ThreadList.jsx
    â”‚       â”œâ”€â”€ ChatMessages.jsx
    â”‚       â”œâ”€â”€ ChatInput.jsx
    â”‚       â”œâ”€â”€ MessageBubble.jsx
    â”‚       â””â”€â”€ ui/                 (shadcn generated)
    â””â”€â”€ public/
```

## End-to-End Verification

1. `npx supabase start` â€” all services running
2. `npm run dev` from root â€” both server (3001) and client (5173) start
3. Open `http://localhost:5173` â€” see login page
4. Sign up with email/password â€” redirected to chat
5. Click "New Chat" â€” thread appears in sidebar
6. Type a message â€” response streams in real-time
7. Send follow-up â€” response is contextually aware
8. Refresh page â€” messages persist, threads load
9. Check Laminar dashboard â€” traces visible with OpenAI spans
10. Check Supabase Studio â€” thread row has `openai_response_id` and `messages` populated

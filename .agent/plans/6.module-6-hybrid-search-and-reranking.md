# Module 6: Hybrid Search & Reranking

## Context

Modules 1-5 are complete. Retrieval currently uses **pure vector search** only — `retrieval.js` calls the `match_document_chunks` RPC (cosine similarity via pgvector). Module 6 adds **keyword search** (Postgres tsvector/tsquery), combines both via **Reciprocal Rank Fusion (RRF)**, and optionally **reranks** results with an LLM scorer. This teaches why vector alone isn't enough and how hybrid strategies improve retrieval quality.

**Complexity:** ⚠️ **Medium**

---

## Architecture Decisions

- **Keyword search**: Postgres `tsvector` generated column + GIN index + `keyword_search_chunks` RPC. No new dependencies — uses built-in Postgres full-text search.
- **RRF fusion**: Application-code in `retrieval.js` (not SQL). Both searches run in parallel via `Promise.all`, then merge in JS. More transparent and easier to test than a single monolithic SQL function.
- **Reranking**: LLM-based scoring via `model.respond()` + Zod schema, matching the `metadata.js` pattern exactly. Enabled via `RERANK_ENABLED=true` env var (defaults off to avoid latency).
- **Search mode**: `SEARCH_MODE` env var (`vector` | `keyword` | `hybrid`, default `hybrid`).
- **Interface stability**: `searchDocuments()` signature unchanged. `chat.js` tool definition unchanged. New fields (`search_mode`, `reranked`) are additive in SSE events.

---

## Tasks

### Task 1: Database Migration

**Create:** `supabase/migrations/00006_hybrid_search.sql`

1. Add generated `search_vector tsvector` column to `document_chunks`:
   ```sql
   ALTER TABLE public.document_chunks
     ADD COLUMN search_vector tsvector
     GENERATED ALWAYS AS (to_tsvector('english', content)) STORED;
   ```
   - `GENERATED ALWAYS AS ... STORED` auto-populates on insert/update — no ingestion pipeline changes needed
   - Backfills existing rows automatically on ALTER TABLE

2. Create GIN index:
   ```sql
   CREATE INDEX idx_document_chunks_search_vector
     ON public.document_chunks USING gin(search_vector);
   ```

3. Create `keyword_search_chunks` RPC (mirrors `match_document_chunks` structure):
   - Params: `query_text text`, `match_user_id uuid`, `match_count int`, `filter_document_ids uuid[]`
   - Uses `plainto_tsquery('english', query_text)` for safe user input handling
   - Returns: `id, document_id, content, chunk_index, rank` (float via `ts_rank`)
   - Scoped by `user_id`, optional `filter_document_ids`

**Validate:** `supabase db reset` applies cleanly.

---

### Task 2: Keyword Search Library

**Create:** `server/lib/keyword-search.js`

Export `keywordSearch(query, userId, { limit=10, filterDocumentIds=null })`:
- Calls `supabaseAdmin.rpc('keyword_search_chunks', ...)`
- Returns `[]` on error (graceful degradation, matches `retrieval.js` pattern)
- Default limit=10 (larger pool for RRF)

**Pattern reference:** Mirrors the RPC call pattern already in `retrieval.js:47-63`.

**Validate:** Unit tests (Task 8).

---

### Task 3: Reranker Library

**Create:** `server/lib/reranker.js`

Export `rerankChunks(query, chunks, limit=5)`:
- Scores each chunk in parallel (`Promise.all`) via `model.respond()` with a prompt asking the LLM to rate relevance 0.0-1.0
- Uses Zod `z.object({ score: z.number().min(0).max(1) })` for validation
- Strips think blocks and code fences from LLM response (same as `metadata.js`)
- 30s timeout per chunk; failed chunks get score=0 (kept but ranked last)
- Content capped at 1000 chars per chunk for LLM context
- `temperature: 0.0` for deterministic scoring
- Returns chunks sorted by `rerank_score` descending, sliced to `limit`

**Pattern reference:** Follow `server/lib/metadata.js` exactly (Zod schema, timeout race, think-block stripping).

**Validate:** Unit tests (Task 8).

---

### Task 4: Update Retrieval Orchestration

**Modify:** `server/lib/retrieval.js`

Major rewrite of this file:

1. **New imports**: `keywordSearch` from `keyword-search.js`, `rerankChunks` from `reranker.js`
2. **Env vars** (read at module load): `SEARCH_MODE` (default `'hybrid'`), `RERANK_ENABLED` (default `false`)
3. **Extract** existing vector search logic into internal `vectorSearch()` helper function
4. **Add** `reciprocalRankFusion(rankedLists, k=60)` pure function:
   - Formula: `score(d) = sum(1 / (k + rank_i))` where `rank_i` is 1-based position
   - Uses `Map` keyed by chunk `id` to deduplicate and sum scores
   - Returns merged list sorted by RRF score descending
5. **Update** `searchDocuments()` orchestration:
   - `fetchLimit = RERANK_ENABLED ? limit * 3 : limit` (larger candidate pool when reranking)
   - If `vector` mode: call `vectorSearch()` only
   - If `keyword` mode: call `keywordSearch()` only
   - If `hybrid` mode: `Promise.all([vectorSearch(), keywordSearch()])` → `reciprocalRankFusion()`
   - If `RERANK_ENABLED`: call `rerankChunks()` on results, map `rerank_score` → `similarity`
   - Attach `results._searchMeta = { search_mode, reranked }` for SSE metadata

**Key**: `searchDocuments()` signature stays the same — callers don't change.

**Validate:** Unit tests (Task 8). Existing chat integration tests unaffected (retrieval is mocked).

---

### Task 5: Update Chat Route SSE Events

**Modify:** `server/routes/chat.js`

In the `search_documents` tool `implementation` (around line 86-89):
- After `searchDocuments()` returns, extract `chunks._searchMeta` (with fallback `{ search_mode: 'vector', reranked: false }`)
- Include `search_mode` and `reranked` in the `tool_result` SSE event payload

Only ~3 lines change. Tool definition, parameters, and everything else stays the same.

**Validate:** Existing chat tests pass. New integration test (Task 9) asserts new fields.

---

### Task 6: Update Frontend

**Modify:** `client/src/pages/ChatPage.jsx` (line 81)

Update the `tool_result` handler to capture `search_mode` and `reranked` fields:
```js
updated[i] = { ...updated[i], chunks: data.chunks, search_mode: data.search_mode, reranked: data.reranked };
```

**Modify:** `client/src/components/ToolCallIndicator.jsx`

1. Add internal `SearchModeBadge` component showing "Hybrid", "Vector", or "Keyword" + optional "+ Reranked" suffix
2. Render badge next to "Found N relevant chunks" when `toolCall.search_mode` exists
3. Switch score label from "Similarity" to "Relevance" when `toolCall.reranked` is true and `chunk.rerank_score` exists
4. Fully backward compatible — badge hidden if fields are absent (e.g., loaded history)

**Validate:** Visual inspection in browser.

---

### Task 7: Update `.env.example`

**Modify:** `.env.example`

Add:
```
# Module 6: Hybrid Search
SEARCH_MODE=hybrid          # 'vector' | 'keyword' | 'hybrid'
RERANK_ENABLED=false        # Set to 'true' to enable LLM-based reranking (adds latency)
```

**Validate:** Visual review.

---

### Task 8: Unit Tests

**Create:** `server/tests/unit/keyword-search.test.js`
- RPC called with correct params
- `filter_document_ids` passed when provided
- Returns data array on success
- Returns `[]` on RPC error

**Create:** `server/tests/unit/reranker.test.js`
- Empty input → empty output
- Scores chunks and sorts by `rerank_score` descending
- Respects `limit` parameter
- Strips markdown code fences from LLM response
- Strips think blocks from reasoning model response
- Failed LLM calls → score 0, chunk kept
- Out-of-range score (>1) rejected by Zod → fallback score 0

**Create:** `server/tests/unit/retrieval.test.js`
- RRF: chunk appearing in both lists gets higher score than single-list chunk
- RRF: deduplicates chunks appearing in both lists
- `_searchMeta` attached to results with correct `search_mode` and `reranked` values
- Metadata filter returning empty docs → returns `[]`

**Validate:** `cd server && npm test` — all pass.

---

### Task 9: Update Integration Tests

**Modify:** `server/tests/integration/chat.test.js`

1. Update `searchDocuments` mock to return array with `_searchMeta`:
   ```js
   searchDocuments: vi.fn().mockImplementation(async () => {
     const chunks = [];
     chunks._searchMeta = { search_mode: 'hybrid', reranked: false };
     return chunks;
   }),
   ```

2. Add test: `tool_result` SSE event includes `search_mode` and `reranked` fields (invoke searchTool in model.act mock, assert SSE payload)

**Validate:** `cd server && npm test` — all existing + new tests pass.

---

### Task 10: Update PROGRESS.md

Add Module 6 completion section.

---

## File Summary

| File | Action |
|------|--------|
| `supabase/migrations/00006_hybrid_search.sql` | Create |
| `server/lib/keyword-search.js` | Create |
| `server/lib/reranker.js` | Create |
| `server/lib/retrieval.js` | Modify (major rewrite) |
| `server/routes/chat.js` | Modify (~3 lines) |
| `client/src/pages/ChatPage.jsx` | Modify (1 line) |
| `client/src/components/ToolCallIndicator.jsx` | Modify |
| `.env.example` | Modify |
| `server/tests/unit/keyword-search.test.js` | Create |
| `server/tests/unit/reranker.test.js` | Create |
| `server/tests/unit/retrieval.test.js` | Create |
| `server/tests/integration/chat.test.js` | Modify |
| `PROGRESS.md` | Modify |

## Execution Order

Task 1 → Tasks 2+3 (parallel) → Task 4 → Task 5 → Tasks 6+7 (parallel) → Tasks 8+9 (parallel) → Task 10

## Verification

1. `supabase db reset` — migration 00006 applies cleanly
2. `cd server && npm test` — all existing + new tests pass
3. Upload a document, chat with a question → ToolCallIndicator shows "Hybrid" badge
4. Set `RERANK_ENABLED=true` → badge shows "Hybrid + Reranked", score label says "Relevance"
5. Set `SEARCH_MODE=vector` → old behavior preserved, badge shows "Vector"
6. Metadata filters still work in hybrid mode

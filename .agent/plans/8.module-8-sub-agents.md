# Module 8: Sub-Agents

## Context

The chat agent currently has three flat tools (`search_documents`, `query_database`, `web_search`). Module 8 adds a hierarchical agent pattern: when the user asks to analyze a specific document in depth, the main agent delegates to an isolated **sub-agent** that receives the full document text in its own context and has its own tools. This teaches context management, agent delegation, and hierarchical tool call display.

**No database migration needed** — `match_document_chunks` and `keyword_search_chunks` RPCs already accept `filter_document_ids` (Modules 4 & 6).

**Complexity:** ⚠️ Medium

---

## Tasks

### Task 1: Extend `searchDocuments` to Accept `document_id` Option

**Modify:** `server/lib/retrieval.js`

Add `document_id` (UUID string) to the options parameter. When present, set `filterDocumentIds = [document_id]` directly, skipping the metadata filter DB lookup.

```js
export async function searchDocuments(query, userId, { limit = 5, threshold = 0.5, metadata_filter, document_id } = {}) {
  // ...
  let filterDocumentIds = null;

  // NEW: scope to single document if document_id provided
  if (document_id) {
    filterDocumentIds = [document_id];
  }
  // Existing metadata filter block (else if)
  else if (metadata_filter && Object.keys(metadata_filter).length > 0) {
    // ...existing code unchanged...
  }
```

**Validate:** Existing retrieval unit tests pass. New test in Task 7.

---

### Task 2: Create Sub-Agent Library

**Create:** `server/lib/sub-agent.js`

Single export: `runSubAgent({ document_id, task, userId, res })`

**Flow:**
1. Fetch document metadata from `documents` table (id, filename, metadata) filtered by `user_id`
2. Fetch all chunks from `document_chunks` ordered by `chunk_index`, limit 50 rows
3. Assemble full text (cap at 50K chars, append `[Document truncated due to length]` if exceeded)
4. Build isolated messages: system prompt with filename + full text + task, user message with task
5. Define `search_within_document` tool (calls `searchDocuments` with `document_id` option, emits `subagent_tool_call`/`subagent_tool_result` SSE events)
6. Run `model.act()` with `maxPredictionRounds: 3`, `temperature: 0.3`
7. Stream `subagent_text_delta` SSE events via `onPredictionFragment`
8. Wrap in `observe()` span for Laminar tracing
9. On error, emit `subagent_error` SSE event and rethrow

**Validate:** Unit tests in Task 7.

---

### Task 3: Add `analyze_document` Tool to Chat Route + Update System Prompt

**Modify:** `server/routes/chat.js`

1. Import `runSubAgent` from `../lib/sub-agent.js`
2. Define `analyzeDocumentTool` using `tool()`:
   - Parameters: `document_id` (z.string), `task` (z.string)
   - Implementation: emits `tool_call` SSE, calls `runSubAgent()`, emits `tool_result` SSE with result or error
   - Wrapped in `observe()` span
3. Add to tools array (always included): `[searchTool, queryDatabaseTool, analyzeDocumentTool]`
4. Update `buildSystemPrompt()` TOOL ROUTING section:
   ```
   - Document content questions (searching across docs) → search_documents
   - Full document analysis (summarize, review, extract from a specific doc) → analyze_document
     - Use query_database first to look up the document_id if you only have a filename
   - Collection/analytical questions (counts, lists, stats) → query_database
   ```

**Validate:** Integration tests in Task 6.

---

### Task 4: Frontend — Handle `subagent_*` SSE Events

**Modify:** `client/src/pages/ChatPage.jsx`

Add three new event handlers in the SSE processing loop:

- `subagent_text_delta` → find last `analyze_document` tool_call, append `data.content` to its `subAgentText` field
- `subagent_tool_call` → find last `analyze_document` tool_call, push `{ name, arguments }` to its `subAgentToolCalls` array
- `subagent_tool_result` → find last unresolved subagent tool call by name, merge result data + `completed: true`

**Validate:** Manual browser test with real sub-agent flow.

---

### Task 5: Frontend — `SubAgentView` Component

**Modify:** `client/src/components/ToolCallIndicator.jsx`

1. Add `FileText` to lucide-react imports
2. Create `SubAgentView({ toolCall, expanded, onToggle })`:
   - `FileText` icon
   - Loading: "Analyzing document..." / Complete: "Analysis complete" / Error: red error text
   - Expanded view shows:
     - Nested `search_within_document` calls (Search icon + query + result count)
     - Sub-agent reasoning text in a muted box
3. Add to dispatcher: `toolCall.name === 'analyze_document'` → `<SubAgentView />`

**Validate:** Manual browser test.

---

### Task 6: Unit Tests — Sub-Agent Library

**Create:** `server/tests/unit/sub-agent.test.js`

~10 tests:
1. Fetches document by `document_id` and `userId`
2. Fetches chunks ordered by `chunk_index`
3. Truncates at 50K chars with notice
4. Throws when document not found
5. Emits `subagent_text_delta` SSE events during streaming
6. Emits `subagent_tool_call` + `subagent_tool_result` when `search_within_document` invoked
7. `search_within_document` calls `searchDocuments` with `document_id` option
8. Sub-agent system message includes filename and assembled content
9. Returns final accumulated sub-agent content
10. Wraps in `observe()` span

**Validate:** `cd server && npm test`

---

### Task 7: Integration Tests — `analyze_document` Tool

**Modify:** `server/tests/integration/chat.test.js`

Mock `runSubAgent` at module level. ~5 tests:
1. `analyze_document` emits `tool_call` SSE with correct arguments
2. `analyze_document` emits `tool_result` SSE when sub-agent completes
3. `analyze_document` emits error `tool_result` when `runSubAgent` throws
4. `analyze_document` tool is always registered in tools array
5. System prompt includes `analyze_document` routing guidance

**Validate:** `cd server && npm test`

---

### Task 8: Update PROGRESS.md

**Modify:** `PROGRESS.md`

Add Module 8 section with all tasks marked `[x]`.

---

## Files Summary

| File | Action |
|------|--------|
| `server/lib/retrieval.js` | Modify — add `document_id` option |
| `server/lib/sub-agent.js` | Create — sub-agent executor |
| `server/routes/chat.js` | Modify — `analyze_document` tool + prompt update |
| `client/src/pages/ChatPage.jsx` | Modify — handle `subagent_*` SSE events |
| `client/src/components/ToolCallIndicator.jsx` | Modify — add `SubAgentView` |
| `server/tests/unit/sub-agent.test.js` | Create |
| `server/tests/integration/chat.test.js` | Modify |
| `PROGRESS.md` | Modify |

## Execution Order

Task 1 → Task 2 → Task 3 → Tasks 4+5 (parallel) → Tasks 6+7 (parallel) → Task 8

## Verification

1. `cd server && npm test` — all tests pass (existing + new)
2. Browser: upload a PDF → ask "Summarize document [filename]" → observe:
   - Main agent calls `query_database` to look up document_id
   - Main agent calls `analyze_document` → `SubAgentView` appears
   - Sub-agent text streams in real-time
   - Any nested `search_within_document` calls shown
   - Final "Analysis complete" with expandable answer
3. Browser: ask "What do my docs say about X?" → routes to `search_documents` (not `analyze_document`)
4. Browser: ask "How many documents?" → routes to `query_database`
5. Error handling: nonexistent document_id → error shown in UI, chat continues
